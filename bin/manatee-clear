#!/usr/bin/env node
// -*- mode: js -*-
// recover a manatee shard in error

var exec = require('child_process').exec;
var path = require('path');
var util = require('util');

var assert = require('assert-plus');
var bunyan = require('bunyan');
var getopt = require('posix-getopt');
var manatee = require('./manatee_common');
var pg = require('pg');
var vasync = require('vasync');
var verror = require('verror');
var zkplus = require('zkplus');

var LOG = bunyan.createLogger({
    name: path.basename(process.argv[1]),
    level: (process.env.LOG_LEVEL || 'info'),
    src: true,
    serializers: {
        err: bunyan.stdSerializers.err
    }
});

var parseOptions = function() {
    var option;
    var opts = {};
    var parser = new getopt.BasicParser('hv', process.argv);

    while((option = parser.getopt()) !== undefined) {
        switch (option.option) {
            case 'h':
                usage();
                break;
            case 'v':
                LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
                if (LOG.level() <= bunyan.DEBUG)
                    LOG = LOG.child({src: true});
                break;
            default:
                usage('invalid option: ' + option.option);
                process.exit(1);
                break;
        }
    }

    if (parser.optind() >= process.argv.length) {
        usage('missing required argument: "shard_id"');
    }

    if (parser.optind() + 1 >= process.argv.length) {
        usage('missing required argument: "zookeeper_ip"');
    }

    opts.shardId = process.argv[parser.optind()];
    opts.zookeeperIp = process.argv[parser.optind() + 1];

    return opts;
};

var usage = function(msg) {
    if (msg) {
        console.error(msg);
    }

    var str = 'clears the manatee shard out of error state';
    str += '\nusage: ' + path.basename(process.argv[1]);
    str += ' shard_id my_ip zookeeper_ip';
    str += '\nexample: ./manatee_clear 1.moray.joyent.us 10.99.99.32 ';
    console.error(str);
    process.exit(msg ? 1 : 0);
};

var cleanupManatee = function(shardId, zookeeperIp, callback) {
    LOG.debug({
        shardId: shardId,
        zookeeperIp: zookeeperIp
    }, 'entering cleanupManatee');

    var tasks = [
        function createZkClient(arg, cb) {
            var zkLog = LOG.child({
                component: 'zookeeper'
            });
            manatee.createZkClient({log: zkLog, zk: zookeeperIp},
                function (err, zk)
                {
                    arg.zk = zk;
                    return cb(err);
                });
        },
        // if primary delete error node
        function deleteErrorNode(arg, cb) {
            if (!arg.isPrimary) {
                LOG.debug('not primary');
                return cb();
            }
            var path_ = '/manatee/' + shardId + '/error';
            LOG.info({
                path: path_
            }, 'removing error node');
            arg.zk.rmr(path_, cb);
            return (undefined);
        }
    ];

    vasync.pipeline({funcs: tasks, arg: {}}, function(err) {
        LOG.debug({err: err}, 'finished cleanupManatee');
        return callback(err);
    });
};

var _opts = parseOptions();

cleanupManatee(_opts.shardId, _opts.zookeeperIp, function(err) {
    if (err) {
        LOG.fatal({err: err}, 'unable to cleanup manatee');
    }
    process.exit(err);
});
